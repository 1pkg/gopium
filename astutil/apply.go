package astutil

import (
	"bytes"
	"context"
	"go/ast"
	"go/parser"
	"sort"
	"strings"
	"sync"

	"1pkg/gopium"
	"1pkg/gopium/collections"
	"1pkg/gopium/fmtio"
	"1pkg/gopium/typepkg"

	"golang.org/x/sync/errgroup"
)

// Apply defines abstraction for
// applying custom action
// on original ast package
// accordingly to gopium
// hierarchic collection
type Apply func(context.Context, *ast.Package, gopium.Locator, collections.Hierarchic) (*ast.Package, error)

// UFFN implements apply and combines:
// - ufmt with fmtio FSPT helper
// - filter helper
// - note helper
var UFFN = combine(
	ufmt(walk, fmtio.FSPT),
	filter(walk),
	note(
		walk,
		typepkg.ParserXToolPackagesAst{
			ModeAst: parser.ParseComments | parser.AllErrors,
		},
		fmtio.Goprint(0, 4, false),
	),
)

// combine helps to pipe several
// ast helpers to single apply func
func combine(funcs ...Apply) Apply {
	return func(
		ctx context.Context,
		pkg *ast.Package,
		loc gopium.Locator,
		h collections.Hierarchic,
	) (*ast.Package, error) {
		// tracks error inside loop
		var err error
		// go through all provided funcs
		for _, fun := range funcs {
			// manage context actions
			// in case of cancelation
			// stop execution
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
			// exec single func
			pkg, err = fun(ctx, pkg, loc, h)
			// in case of any error
			// just propagate it
			if err != nil {
				return nil, err
			}
		}
		return pkg, nil
	}
}

// ufmt helps to update ast package
// accordingly to gopium struct result
// using custom fmtio ast formatter
func ufmt(w gopium.Walk, fmt fmtio.Ast) Apply {
	return func(
		ctx context.Context,
		pkg *ast.Package,
		loc gopium.Locator,
		h collections.Hierarchic,
	) (*ast.Package, error) {
		// just reuse inner walk helper
		wpkg, err := w(
			ctx,
			pkg,
			fmtioast{fmt: fmt},
			&cmpid{loc: loc, sts: h.Flat()},
		)
		if err != nil {
			return nil, err
		}
		// if no error happened
		// just apply format to ast
		return wpkg.(*ast.Package), nil
	}
}

// filter helps to filter structs
// docs and comments from ast type spec
//
// it filters only comments inside
// result structs and autogenerated comments
func filter(w gopium.Walk) Apply {
	return func(
		ctx context.Context,
		pkg *ast.Package,
		loc gopium.Locator,
		h collections.Hierarchic,
	) (*ast.Package, error) {
		// prepare structs boundaries
		bc := &bcollect{bs: make(collections.Boundaries, 0, h.Len())}
		// collect structs boundaries
		if _, err := w(
			ctx,
			pkg,
			bc,
			&cmpid{loc: loc, sts: h.Flat()},
		); err != nil {
			return nil, err
		}
		// create sync error group
		// with cancelation context
		group, gctx := errgroup.WithContext(ctx)
		// go through package files
		for _, file := range pkg.Files {
			// manage context actions
			// in case of cancelation
			// stop execution
			select {
			case <-gctx.Done():
				return nil, gctx.Err()
			default:
			}
			// capture file copy
			file := file
			group.Go(func() error {
				// go through all file comments
				for _, comments := range file.Comments {
					// prepare comment slice
					comlist := make([]*ast.Comment, 0, len(comments.List))
					// go through comment slice
					for _, com := range comments.List {
						// in case comment has autogenerated prefix skip it
						if strings.Contains(com.Text, gopium.STAMP) {
							continue
						}
						// if comment is inside boundaries skip it
						if bc.bs.Inside(com.Slash) {
							continue
						}
						// otherwise append comment to slice
						comlist = append(comlist, com)
					}
					// update comment list
					comments.List = comlist
				}
				return nil
			})
		}
		return pkg, group.Wait()
	}
}

// note helps to update ast package
// accordingly to gopium struct result
//
// it synchronizes all docs and comments by
// regenerating ast for each file in order
// to update all definitions position
// and ingest docs and comments directly
// to file with correct calculated positions
func note(w gopium.Walk, p gopium.AstParser, pr fmtio.Printer) Apply {
	return func(
		ctx context.Context,
		pkg *ast.Package,
		loc gopium.Locator,
		h collections.Hierarchic,
	) (*ast.Package, error) {
		// create sync error group
		// with cancelation context
		// and sync map to store updated files
		var files sync.Map
		group, gctx := errgroup.WithContext(ctx)
		// concurently go through package files
		for name, file := range pkg.Files {
			// manage context actions
			// in case of cancelation
			// stop execution
			select {
			case <-gctx.Done():
				return nil, gctx.Err()
			default:
			}
			// capture name and file copies
			name := name
			file := file
			group.Go(func() error {
				// print ast to buffer
				var buf bytes.Buffer
				if err := pr(gctx, &buf, loc.Root(), file); err != nil {
					return err
				}
				// parse ast back to file
				// and push child fset to locator
				pkg, nloc, err := p.ParseAst(gctx, buf.Bytes()...)
				if err != nil {
					return err
				}
				// build sorted collection for cat
				cat, ok := h.Cat(name)
				// skip cat if not exists
				if !ok {
					return nil
				}
				// go through file structs
				// and note all comments
				file := pkg.Files["file"]
				node, err := w(
					gctx, file,
					pressdoccom{file: file},
					cmpnote{cmp: cmpsorted{sts: cat.Sorted()}},
				)
				if err != nil {
					return err
				}
				// sort all comments by their ast pos
				file = node.(*ast.File)
				sort.SliceStable(file.Comments, func(i, j int) bool {
					return file.Comments[i].Pos() < file.Comments[j].Pos()
				})
				// save update file and loc results
				files.Store(name, file)
				loc.Fset(name, nloc.Root())
				return nil
			})
		}
		// wait until walk is done
		// in case of any error
		// just return it back
		if err := group.Wait(); err != nil {
			return nil, err
		}
		// otherwise update ast pkg files
		// with synced files result
		files.Range(func(name interface{}, file interface{}) bool {
			pkg.Files[name.(string)] = file.(*ast.File)
			return true
		})
		return pkg, nil
	}
}
