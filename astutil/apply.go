package astutil

import (
	"bytes"
	"context"
	"errors"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"sort"
	"strings"
	"sync"

	"1pkg/gopium"
	"1pkg/gopium/collections"
	"1pkg/gopium/fmtio"

	"golang.org/x/sync/errgroup"
)

// Apply defines abstraction for
// applying custom action
// on original ast package
// accordingly to gopium
// hierarchic collection
type Apply func(
	context.Context,
	*ast.Package,
	gopium.Locator,
	collections.Hierarchic,
) (*ast.Package, error)

// FFN implements apply and combines:
// - fmt with fmtio FSPT helper
// - filter helper
// - note helper
var FFN = combine(
	fmt(fmtio.FSPT),
	filter,
	note,
)

// combine helps to pipe several
// ast helpers to single apply func
func combine(funcs ...Apply) Apply {
	return func(
		ctx context.Context,
		pkg *ast.Package,
		loc gopium.Locator,
		hsts collections.Hierarchic,
	) (*ast.Package, error) {
		// tracks error inside loop
		var err error
		// go through all provided funcs
		for _, fun := range funcs {
			// manage context actions
			// in case of cancelation
			// stop execution
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
			// exec single func
			pkg, err = fun(ctx, pkg, loc, hsts)
			// in case of any error
			// just propagate it
			if err != nil {
				return nil, err
			}
		}
		return pkg, nil
	}
}

// fmt helps to update ast package
// accordingly to gopium struct result
// using custom fmtio ast formatter
func fmt(sta fmtio.Ast) Apply {
	return func(
		ctx context.Context,
		pkg *ast.Package,
		loc gopium.Locator,
		hsts collections.Hierarchic,
	) (*ast.Package, error) {
		// just reuse inner walk helper
		// and apply format to ast
		return walkPkg(
			ctx,
			pkg,
			compid(loc, hsts),
			wact(sta),
		)
	}
}

// filter helps to filter relevant
// docs and comments from ast.TypeSpec,
// it filters only comments inside
// relevant structs and autogenerated comments
func filter(
	ctx context.Context,
	pkg *ast.Package,
	loc gopium.Locator,
	hsts collections.Hierarchic,
) (*ast.Package, error) {
	// prepare structs boundaries
	type boundary struct{ Pos, End token.Pos }
	boundaries := make([]boundary, 0, len(hsts))
	// collect structs boundaries
	if _, err := walkPkg(
		ctx,
		pkg,
		compid(loc, hsts),
		func(ts *ast.TypeSpec, st gopium.Struct) error {
			// check that we are working with ast.StructType
			tts, ok := ts.Type.(*ast.StructType)
			if !ok {
				return errors.New("boundaries could only be collected from ast.StructType")
			}
			// collect structs boundaries
			boundaries = append(boundaries, boundary{
				Pos: tts.Fields.Opening,
				End: tts.Fields.Closing,
			})
			return nil
		},
	); err != nil {
		return nil, err
	}
	// create sync error group
	// with cancelation context
	group, gctx := errgroup.WithContext(ctx)
	// go through package files
	for _, file := range pkg.Files {
		// manage context actions
		// in case of cancelation
		// stop execution
		select {
		case <-gctx.Done():
			return pkg, gctx.Err()
		default:
		}
		// capture file copy
		file := file
		group.Go(func() error {
			// go through all file comments
			for _, comments := range file.Comments {
				// manage context actions
				// in case of cancelation
				// stop execution
				select {
				case <-gctx.Done():
					return gctx.Err()
				default:
				}
				// prepare comment slice
				comlist := make([]*ast.Comment, 0, len(comments.List))
				// go through comment slice
				blen := len(boundaries)
			loop:
				for _, com := range comments.List {
					// in case comment has autogenerated prefix skip it
					if strings.Contains(com.Text, gopium.STAMP) {
						continue loop
					}
					// in case comment is inside boundaries skip it
					// use binary search to check boundaries
					l, r := 0, blen-1
					for l <= r {
						// calculate the index
						i := (l + r) / 2
						b := boundaries[i]
						// if comment is inside boundaries skip it
						if b.Pos <= com.Slash && com.Slash <= b.End {
							continue loop
						}
						// if comment is inside
						// left half of boundaries
						// search there
						if b.Pos > com.Slash {
							r = i - 1
							continue
						}
						// if comment is inside
						// right half of boundaries
						// search there
						if b.End < com.Slash {
							l = i + 1
							continue
						}
						// otherwise break from iteration
						break
					}
					// append comment to slice
					comlist = append(comlist, com)
				}
				// update comment list
				comments.List = comlist
			}
			return nil
		})
	}
	return pkg, group.Wait()
}

// note helps to update ast.Package
// accordingly to gopium.Struct result,
// it synchronizes all docs and comments by
//  regenerating ast for each file
// in order to update all definitions position
// and ingest docs and comments directly
// to file with correct calculated position
func note(
	ctx context.Context,
	pkg *ast.Package,
	loc gopium.Locator,
	hsts collections.Hierarchic,
) (*ast.Package, error) {
	// create sync error group
	// with cancelation context
	// and sync map to store updated files
	var files sync.Map
	group, gctx := errgroup.WithContext(ctx)
	// concurently go through package files
	for name, file := range pkg.Files {
		// manage context actions
		// in case of cancelation
		// stop execution
		select {
		case <-gctx.Done():
			return pkg, gctx.Err()
		default:
		}
		// capture name and file copies
		name := name
		file := file
		group.Go(func() error {
			// manage context actions
			// in case of cancelation
			// stop execution and return error
			select {
			case <-gctx.Done():
				return gctx.Err()
			default:
			}
			// print ast to buffer
			var buf bytes.Buffer
			err := printer.Fprint(
				&buf,
				loc.Root(),
				file,
			)
			if err != nil {
				return err
			}
			// parse ast back to file
			fset := token.NewFileSet()
			if file, err = parser.ParseFile(
				fset,
				"",
				buf.String(),
				parser.ParseComments,
			); err != nil {
				return err
			}
			// push child fset to locator
			loc.Fset(name, fset)
			// go through file structs
			// and note all comments
			if file, err = walkFile(
				gctx,
				file,
				compwnote(comploc(loc, name, hsts)),
				func(ts *ast.TypeSpec, st gopium.Struct) error {
					// check that we are working with ast.StructType
					tts, ok := ts.Type.(*ast.StructType)
					if !ok {
						return errors.New("notesync could only be applied to ast.StructType")
					}
					// prepare struct docs slice
					stdocs := make([]*ast.Comment, 0, len(st.Doc))
					// collect all docs from resulted structure
					for _, doc := range st.Doc {
						// doc position is position of name - len of `type` keyword
						slash := ts.Name.Pos() - token.Pos(6)
						sdoc := ast.Comment{Slash: slash, Text: doc}
						stdocs = append(stdocs, &sdoc)
					}
					// update file comments list
					file.Comments = append(file.Comments, &ast.CommentGroup{List: stdocs})
					// prepare struct comments slice
					stcoms := make([]*ast.Comment, 0, len(st.Comment))
					// collect all comments from resulted structure
					for _, com := range st.Comment {
						// comment position is end of type decl
						slash := ts.Type.End()
						scom := ast.Comment{Slash: slash, Text: com}
						stcoms = append(stcoms, &scom)
					}
					// update file comments list
					file.Comments = append(file.Comments, &ast.CommentGroup{List: stcoms})
					// go through all resulted structure fields
					for index, field := range st.Fields {
						// if index is greater that ast
						// field number break the loop
						if len(tts.Fields.List) <= index {
							break
						}
						// get the field from ast
						astfield := tts.Fields.List[index]
						// collect all docs from resulted structure
						fdocs := make([]*ast.Comment, 0, len(field.Doc))
						for _, doc := range field.Doc {
							// doc position is position of name - 1
							slash := astfield.Pos() - token.Pos(1)
							fdoc := ast.Comment{Slash: slash, Text: doc}
							fdocs = append(fdocs, &fdoc)
						}
						// update file comments list
						file.Comments = append(file.Comments, &ast.CommentGroup{List: fdocs})
						// collect all comments from resulted structure
						fcoms := make([]*ast.Comment, 0, len(field.Comment))
						for _, com := range field.Comment {
							// comment position is end of field type
							slash := astfield.Type.End()
							fcom := ast.Comment{Slash: slash, Text: com}
							fcoms = append(fcoms, &fcom)
						}
						// update file comments list
						file.Comments = append(file.Comments, &ast.CommentGroup{List: fcoms})
					}
					return nil
				},
			); err != nil {
				return err
			}
			// sort all comments by their ast pos
			sort.SliceStable(file.Comments, func(i, j int) bool {
				// sort safe guard
				if len(file.Comments[i].List) == 0 {
					return true
				}
				// sort safe guard
				if len(file.Comments[j].List) == 0 {
					return false
				}
				return file.Comments[i].Pos() < file.Comments[j].Pos()
			})
			// save update file to result map
			files.Store(name, file)
			return nil
		})
	}
	// wait until walk is done
	// in case of any error
	// just return it back
	if err := group.Wait(); err != nil {
		return pkg, err
	}
	files.Range(func(key interface{}, val interface{}) bool {
		pkg.Files[key.(string)] = val.(*ast.File)
		return true
	})
	return pkg, nil
}
