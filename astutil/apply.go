package astutil

import (
	"bytes"
	"context"
	"go/ast"
	"go/parser"
	"go/token"
	"sort"
	"strings"
	"sync"

	"1pkg/gopium"
	"1pkg/gopium/astext"
	"1pkg/gopium/collections"
	"1pkg/gopium/fmtio"
	"1pkg/gopium/typepkg"

	"golang.org/x/sync/errgroup"
)

// Apply defines abstraction for
// applying custom action
// on original ast package
// accordingly to gopium
// hierarchic collection
type Apply func(context.Context, *ast.Package, gopium.Locator, collections.Hierarchic) (*ast.Package, error)

// FFN implements apply and combines:
// - fmt with fmtio FSPT helper
// - filter helper
// - note helper
var FFN = combine(
	ufmt(astext.WalkSt, fmtio.FSPT),
	filter(astext.WalkSt),
	note(
		astext.WalkSt,
		typepkg.ParserXToolPackagesAst{
			ModeAst: parser.ParseComments | parser.AllErrors,
		},
		fmtio.Goprint(0, 4, false),
	),
)

// combine helps to pipe several
// ast helpers to single apply func
func combine(funcs ...Apply) Apply {
	return func(
		ctx context.Context,
		pkg *ast.Package,
		loc gopium.Locator,
		h collections.Hierarchic,
	) (*ast.Package, error) {
		// tracks error inside loop
		var err error
		// go through all provided funcs
		for _, fun := range funcs {
			// manage context actions
			// in case of cancelation
			// stop execution
			select {
			case <-ctx.Done():
				return nil, ctx.Err()
			default:
			}
			// exec single func
			pkg, err = fun(ctx, pkg, loc, h)
			// in case of any error
			// just propagate it
			if err != nil {
				return nil, err
			}
		}
		return pkg, nil
	}
}

// ufmt helps to update ast package
// accordingly to gopium struct result
// using custom fmtio ast formatter
func ufmt(w astext.Walk, fmt fmtio.Ast) Apply {
	return func(
		ctx context.Context,
		pkg *ast.Package,
		loc gopium.Locator,
		h collections.Hierarchic,
	) (*ast.Package, error) {
		// just reuse inner walk helper
		wpkg, err := w(ctx, pkg, astext.Wcmpid(loc, h), astext.Wact(fmt))
		if err != nil {
			return nil, err
		}
		// if no error happened
		// just apply format to ast
		return wpkg.(*ast.Package), nil
	}
}

// filter helps to filter structs
// docs and comments from ast type spec
//
// it filters only comments inside
// result structs and autogenerated comments
func filter(w astext.Walk) Apply {
	return func(
		ctx context.Context,
		pkg *ast.Package,
		loc gopium.Locator,
		h collections.Hierarchic,
	) (*ast.Package, error) {
		// prepare structs boundaries
		bs := make(collections.Boundaries, 0, h.Len())
		// collect structs boundaries
		if _, err := w(
			ctx,
			pkg,
			astext.Wcmpid(loc, h),
			func(ts *ast.TypeSpec, st gopium.Struct) error {
				// collect structs boundaries
				tts := ts.Type.(*ast.StructType)
				bs = append(bs, collections.Boundary{
					First: tts.Fields.Opening,
					Last:  tts.Fields.Closing,
				})
				return nil
			},
		); err != nil {
			return nil, err
		}
		// create sync error group
		// with cancelation context
		group, gctx := errgroup.WithContext(ctx)
		// go through package files
		for _, file := range pkg.Files {
			// manage context actions
			// in case of cancelation
			// stop execution
			select {
			case <-gctx.Done():
				return nil, gctx.Err()
			default:
			}
			// capture file copy
			file := file
			group.Go(func() error {
				// go through all file comments
				for _, comments := range file.Comments {
					// prepare comment slice
					comlist := make([]*ast.Comment, 0, len(comments.List))
					// go through comment slice
					for _, com := range comments.List {
						// in case comment has autogenerated prefix skip it
						if strings.Contains(com.Text, gopium.STAMP) {
							continue
						}
						// if comment is inside boundaries skip it
						if bs.Inside(com.Slash) {
							continue
						}
						// otherwise append comment to slice
						comlist = append(comlist, com)
					}
					// update comment list
					comments.List = comlist
				}
				return nil
			})
		}
		return pkg, group.Wait()
	}
}

// note helps to update ast package
// accordingly to gopium struct result
//
// it synchronizes all docs and comments by
// regenerating ast for each file in order
// to update all definitions position
// and ingest docs and comments directly
// to file with correct calculated positions
func note(w astext.Walk, p gopium.AstParser, pr fmtio.Printer) Apply {
	return func(
		ctx context.Context,
		pkg *ast.Package,
		loc gopium.Locator,
		h collections.Hierarchic,
	) (*ast.Package, error) {
		// create sync error group
		// with cancelation context
		// and sync map to store updated files
		var files sync.Map
		group, gctx := errgroup.WithContext(ctx)
		// concurently go through package files
		for name, file := range pkg.Files {
			// manage context actions
			// in case of cancelation
			// stop execution
			select {
			case <-gctx.Done():
				return nil, gctx.Err()
			default:
			}
			// capture name and file copies
			name := name
			file := file
			group.Go(func() error {
				// print ast to buffer
				var buf bytes.Buffer
				if err := pr(&buf, loc.Root(), file); err != nil {
					return err
				}
				// parse ast back to file
				// and push child fset to locator
				pkg, nloc, err := p.ParseAst(gctx, buf.Bytes()...)
				if err != nil {
					return err
				}
				loc.Fset(name, nloc.Root())
				// go through file structs
				// and note all comments
				comp := astext.Wcmploc(loc, name, h)
				file := pkg.Files["file"]
				node, err := w(gctx, file, astext.Wcmpnote(comp), pressdoc(file))
				if err != nil {
					return err
				}
				// sort all comments by their ast pos
				file = node.(*ast.File)
				sort.SliceStable(file.Comments, func(i, j int) bool {
					return file.Comments[i].Pos() < file.Comments[j].Pos()
				})
				// save update file to result map
				files.Store(name, file)
				return nil
			})
		}
		// wait until walk is done
		// in case of any error
		// just return it back
		if err := group.Wait(); err != nil {
			return nil, err
		}
		// otherwise update ast pkg files
		// with synced files result
		files.Range(func(name interface{}, file interface{}) bool {
			pkg.Files[name.(string)] = file.(*ast.File)
			return true
		})
		return pkg, nil
	}
}

// pressdoc helps to create walk wact
// which presses comments from
// gopium structure to ast file
func pressdoc(file *ast.File) astext.Wact {
	return func(ts *ast.TypeSpec, st gopium.Struct) error {
		// prepare struct docs slice
		stdocs := make([]*ast.Comment, 0, len(st.Doc))
		// collect all docs from resulted structure
		for _, doc := range st.Doc {
			// doc position is position of name - len of `type` keyword
			slash := ts.Name.Pos() - token.Pos(6)
			sdoc := ast.Comment{Slash: slash, Text: doc}
			stdocs = append(stdocs, &sdoc)
		}
		// update file comments list
		if len(stdocs) > 0 {
			file.Comments = append(file.Comments, &ast.CommentGroup{List: stdocs})
		}
		// prepare struct comments slice
		stcoms := make([]*ast.Comment, 0, len(st.Comment))
		// collect all comments from resulted structure
		for _, com := range st.Comment {
			// comment position is end of type decl
			slash := ts.Type.End()
			scom := ast.Comment{Slash: slash, Text: com}
			stcoms = append(stcoms, &scom)
		}
		// update file comments list
		if len(stcoms) > 0 {
			file.Comments = append(file.Comments, &ast.CommentGroup{List: stcoms})
		}
		// go through all resulted structure fields
		tts := ts.Type.(*ast.StructType)
		for index, field := range st.Fields {
			// get the field from ast
			astfield := tts.Fields.List[index]
			// collect all docs from resulted structure
			fdocs := make([]*ast.Comment, 0, len(field.Doc))
			for _, doc := range field.Doc {
				// doc position is position of name - 1
				slash := astfield.Pos() - token.Pos(1)
				fdoc := ast.Comment{Slash: slash, Text: doc}
				fdocs = append(fdocs, &fdoc)
			}
			// update file comments list
			if len(fdocs) > 0 {
				file.Comments = append(file.Comments, &ast.CommentGroup{List: fdocs})
			}
			// collect all comments from resulted structure
			fcoms := make([]*ast.Comment, 0, len(field.Comment))
			for _, com := range field.Comment {
				// comment position is end of field type
				slash := astfield.Type.End()
				fcom := ast.Comment{Slash: slash, Text: com}
				fcoms = append(fcoms, &fcom)
			}
			// update file comments list
			if len(fcoms) > 0 {
				file.Comments = append(file.Comments, &ast.CommentGroup{List: fcoms})
			}
		}
		return nil
	}
}
