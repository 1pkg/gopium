package apply

import (
	"context"
	"errors"
	"go/ast"
	"go/token"
	"strings"

	"1pkg/gopium"
	"1pkg/gopium/collections"

	"golang.org/x/sync/errgroup"
)

// filter helps to filter relevant
// docs and comments from ast.TypeSpec,
// it filters only comments inside
// relevant structs and autogenerated comments
func filter(
	ctx context.Context,
	pkg *ast.Package,
	loc gopium.Locator,
	hsts collections.Hierarchic,
) (*ast.Package, error) {
	// prepare structs boundaries
	type boundary struct{ Pos, End token.Pos }
	boundaries := make([]boundary, 0, len(hsts))
	// collect structs boundaries
	if _, err := walkPkg(
		ctx,
		pkg,
		compid(loc, hsts),
		func(ts *ast.TypeSpec, st gopium.Struct) error {
			// check that we are working with ast.StructType
			tts, ok := ts.Type.(*ast.StructType)
			if !ok {
				return errors.New("boundaries could only be collected from ast.StructType")
			}
			// collect structs boundaries
			boundaries = append(boundaries, boundary{
				Pos: tts.Fields.Opening,
				End: tts.Fields.Closing,
			})
			return nil
		},
	); err != nil {
		return nil, err
	}
	// create sync error group
	// with cancelation context
	group, gctx := errgroup.WithContext(ctx)
	// go through package files
	for _, file := range pkg.Files {
		// manage context actions
		// in case of cancelation
		// stop execution
		select {
		case <-gctx.Done():
			return pkg, gctx.Err()
		default:
		}
		// capture file copy
		file := file
		group.Go(func() error {
			// go through all file comments
			for _, comments := range file.Comments {
				// manage context actions
				// in case of cancelation
				// stop execution
				select {
				case <-gctx.Done():
					return gctx.Err()
				default:
				}
				// prepare comment slice
				comlist := make([]*ast.Comment, 0, len(comments.List))
				// go through comment slice
				blen := len(boundaries)
			loop:
				for _, com := range comments.List {
					// in case comment has autogenerated prefix skip it
					if strings.Contains(com.Text, gopium.STAMP) {
						continue loop
					}
					// in case comment is inside boundaries skip it
					// use binary search to check boundaries
					l, r := 0, blen-1
					for l <= r {
						// calculate the index
						i := (l + r) / 2
						b := boundaries[i]
						// if comment is inside boundaries skip it
						if b.Pos <= com.Slash && com.Slash <= b.End {
							continue loop
						}
						// if comment is inside
						// left half of boundaries
						// search there
						if b.Pos > com.Slash {
							r = i - 1
							continue
						}
						// if comment is inside
						// right half of boundaries
						// search there
						if b.End < com.Slash {
							l = i + 1
							continue
						}
						// otherwise break from iteration
						break
					}
					// append comment to slice
					comlist = append(comlist, com)
				}
				// update comment list
				comments.List = comlist
			}
			return nil
		})
	}
	return pkg, group.Wait()
}
